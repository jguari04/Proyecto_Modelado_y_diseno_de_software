# -*- coding: utf-8 -*-
from __future__ import annotations

# -----------------------------
# Librerías estándar / GUI
# -----------------------------
import sys
from pathlib import Path
from datetime import date, datetime
import json
import tkinter as tk
from tkinter import ttk, messagebox, filedialog, simpledialog

# Tema visual
import ttkbootstrap as tb
from ttkbootstrap.constants import *

# -------------------------------------------------------------------
# 1) Asegurar path del paquete (permitir importar desde ./src)
# -------------------------------------------------------------------
ROOT = Path(__file__).resolve().parents[1]  # carpeta del proyecto
SRC  = ROOT / "src"
if str(SRC) not in sys.path:
    sys.path.insert(0, str(SRC))

# -------------------------------------------------------------------
# 2) Imports internos del proyecto
# -------------------------------------------------------------------
from finanzasportable.services.db import (
    connect,
    ensure_schema,
    clone_core_from_general,
    db_empty_of_core_tables,
    db_path_general,
    db_path_year,
    db_path_month,
)
from finanzasportable.utils.formats import parse_amount, money
from finanzasportable.services.importer import (
    read_any_table,
    guess_role,
    normalize_with_mapping,
    import_rows,
)

# -------------------------------------------------------------------
# Helpers UI / secciones
# -------------------------------------------------------------------
def build_section(parent: tk.Misc, title: str):
    wrap = ttk.Frame(parent, padding=(8, 6, 8, 8))
    head = ttk.Frame(wrap)
    head.pack(fill=tk.X, pady=(0, 6))
    ttk.Label(head, text=title, font=("Helvetica", 11, "bold")).pack(side=tk.LEFT)
    ttk.Separator(wrap).pack(fill=tk.X)
    body = ttk.Frame(wrap)
    body.pack(fill=tk.BOTH, expand=True, pady=(6, 0))
    return wrap, body

def _json_or_empty(s: str | None) -> dict:
    if not s:
        return {}
    try:
        return json.loads(s)
    except Exception:
        return {}

def _meta_with_position(s: str | None, pos: int) -> str:
    d = _json_or_empty(s)
    d["position"] = int(pos)
    return json.dumps(d, ensure_ascii=False)

def _position_from_meta(s: str | None) -> int:
    d = _json_or_empty(s)
    try:
        return int(d.get("position", 10**9))
    except Exception:
        return 10**9

# -------------------------------------------------------------------
# 3) Wizard de Importación
# -------------------------------------------------------------------
class ImportWizard(tk.Toplevel):
    def __init__(self, master: tk.Misc, conn, default_account: str = "General"):
        super().__init__(master)
        self.conn = conn
        self.title("Importar CSV/Excel")
        self.geometry("760x560")
        self.resizable(True, True)

        self.path_var = tk.StringVar()
        self.sheet_var = tk.StringVar(value="")
        self.header_var = tk.IntVar(value=0)
        self.default_account = tk.StringVar(value=default_account)

        self.df = None
        self.columns: list[str] = []

        frm = ttk.Frame(self, padding=12)
        frm.pack(fill="both", expand=True)

        r1 = ttk.Frame(frm); r1.pack(fill="x", pady=4)
        ttk.Label(r1, text="Archivo (.csv / .xlsx)").pack(side="left")
        ttk.Entry(r1, textvariable=self.path_var).pack(side="left", fill="x", expand=True, padx=6)
        ttk.Button(r1, text="Buscar…", command=self.browse).pack(side="left")

        r2 = ttk.Frame(frm); r2.pack(fill="x", pady=4)
        ttk.Label(r2, text="Hoja (Excel)").pack(side="left")
        self.sheet_cb = ttk.Combobox(r2, textvariable=self.sheet_var, width=28, state="readonly")
        self.sheet_cb.pack(side="left", padx=6)
        ttk.Label(r2, text="Fila encabezado").pack(side="left")
        ttk.Spinbox(r2, from_=0, to=100, textvariable=self.header_var, width=6).pack(side="left", padx=6)
        ttk.Button(r2, text="Previsualizar", command=self.preview).pack(side="left", padx=6)

        mapf = ttk.LabelFrame(frm, text="Mapeo de columnas"); mapf.pack(fill="x", pady=8)
        self.cmb: dict[str, ttk.Combobox] = {}
        for r in ["date", "account", "description", "amount", "currency"]:
            fr = ttk.Frame(mapf); fr.pack(fill="x", pady=2)
            ttk.Label(fr, text=r.capitalize(), width=14).pack(side="left")
            cb = ttk.Combobox(fr, width=42, state="readonly")
            cb.pack(side="left", fill="x", expand=True)
            self.cmb[r] = cb

        dfr = ttk.Frame(mapf); dfr.pack(fill="x", pady=2)
        ttk.Label(dfr, text="Cuenta por defecto", width=14).pack(side="left")
        ttk.Entry(dfr, textvariable=self.default_account).pack(side="left", fill="x", expand=True)

        self.preview_box = tk.Text(frm, height=14)
        self.preview_box.pack(fill="both", expand=True, pady=(6, 6))

        br = ttk.Frame(frm); br.pack(fill="x")
        ttk.Button(br, text="Cancelar", bootstyle=SECONDARY, command=self.destroy).pack(side="right", padx=6)
        ttk.Button(br, text="Importar", bootstyle=PRIMARY, command=self.do_import).pack(side="right")

    def browse(self):
        p = filedialog.askopenfilename(
            title="Elegir archivo",
            filetypes=[("CSV/Excel", "*.csv *.xlsx *.xls"), ("Todos", "*.*")],
        )
        if not p:
            return
        self.path_var.set(p)
        if p.lower().endswith((".xlsx", ".xls")):
            try:
                import pandas as pd
                xls = pd.ExcelFile(p)
                self.sheet_cb["values"] = xls.sheet_names
                if xls.sheet_names:
                    self.sheet_var.set(xls.sheet_names[0])
            except Exception:
                self.sheet_cb["values"] = []
                self.sheet_var.set("")

    def preview(self):
        try:
            df = read_any_table(
                Path(self.path_var.get()),
                sheet=self.sheet_var.get() or None,
                header_row=self.header_var.get(),
            )
        except Exception as e:
            messagebox.showerror("Error leyendo", str(e), parent=self)
            return

        self.df = df
        self.columns = [str(c) for c in df.columns]
        for role, cb in self.cmb.items():
            guess = None
            for c in self.columns:
                if guess_role(c) == role:
                    guess = c; break
            cb["values"] = self.columns
            cb.set(guess or "")

        self.preview_box.delete("1.0", "end")
        self.preview_box.insert("end", df.head(30).to_string())

    def do_import(self):
        if self.df is None:
            messagebox.showwarning("Atención", "Previsualizá y mapeá columnas.", parent=self)
            return
        mapping = {role: self.cmb[role].get() or None for role in self.cmb}
        defaults = {"account": self.default_account.get().strip() or "General", "currency": "ARS"}
        try:
            norm = normalize_with_mapping(self.df, mapping, defaults)
            n_acc, n_tx = import_rows(self.conn, norm)
            messagebox.showinfo("Importación", f"Cuentas nuevas: {n_acc}\nMovimientos insertados: {n_tx}", parent=self)
            self.destroy()
        except Exception as e:
            messagebox.showerror("Error importando", str(e), parent=self)

# -------------------------------------------------------------------
# 4) MPApp
# -------------------------------------------------------------------
class MPApp(tb.Window):
    def __init__(self):
        super().__init__(title="Finanzas Portable — Jose Guari", themename="darkly")
        self.geometry("1200x720")

        today = date.today()
        self.scope_mode  = tk.StringVar(value="general")   # general | year | month
        self.scope_year  = tk.IntVar(value=today.year)
        self.scope_month = tk.IntVar(value=today.month)

        self.db_path = db_path_general()
        self.prepare_db()

        self._build_header()
        self._build_body()
        self._toggle_scope_widgets()

    # --- DB scope helpers ---
    def current_path(self) -> Path:
        mode = self.scope_mode.get()
        if mode == "general":
            return db_path_general()
        elif mode == "year":
            return db_path_year(self.scope_year.get())
        else:
            return db_path_month(self.scope_year.get(), self.scope_month.get())

    def prepare_db(self):
        self.db_path = self.current_path()
        ensure_schema(self.db_path)
        if db_empty_of_core_tables(self.db_path):
            clone_core_from_general(self.db_path)

    # --- Header ---
    def _build_header(self):
        hdr = ttk.Frame(self, padding=10); hdr.pack(fill=tk.X)

        saldo = ttk.Frame(hdr); saldo.pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(saldo, text="Disponible", font=("Helvetica", 11, "bold")).pack(anchor="w")
        self.total_var = tk.StringVar(value="$ 0,00")
        ttk.Label(saldo, textvariable=self.total_var, font=("Helvetica", 28, "bold")).pack(anchor="w", pady=(2,0))

        right = ttk.Frame(hdr); right.pack(side=tk.RIGHT)
        mrow = ttk.Frame(right); mrow.pack(anchor="e", pady=(0,6))
        ttk.Label(mrow, text="Ámbito:").pack(side=tk.LEFT, padx=(0,6))
        cmb = ttk.Combobox(mrow, width=10, state="readonly", values=["General","Año","Mes"])
        cmb.current(0); cmb.pack(side=tk.LEFT)
        cmb.bind("<<ComboboxSelected>>", lambda _e: self._on_scope_change(cmb.get()))

        self.year_sp  = ttk.Spinbox(mrow, from_=2000, to=2100, width=6, textvariable=self.scope_year)
        self.month_sp = ttk.Spinbox(mrow, from_=1, to=12, width=4, textvariable=self.scope_month)
        ttk.Label(mrow, text="Año").pack(side=tk.LEFT, padx=(8,2));  self.year_sp.pack(side=tk.LEFT)
        ttk.Label(mrow, text="Mes").pack(side=tk.LEFT, padx=(8,2));  self.month_sp.pack(side=tk.LEFT)

        btns = ttk.Frame(right); btns.pack(anchor="e")
        ttk.Button(btns, text="Añadir",     bootstyle=SUCCESS, command=self.open_add_modal).pack(side=tk.LEFT, padx=6)
        ttk.Button(btns, text="Actualizar", bootstyle=PRIMARY, command=self.refresh_all).pack(side=tk.LEFT, padx=6)
        ttk.Button(btns, text="Importar",   bootstyle=INFO,    command=self.on_import).pack(side=tk.LEFT, padx=6)
        ttk.Button(btns, text="Exportar",   bootstyle=INFO,    command=self.export_to_excel).pack(side=tk.LEFT, padx=6)

    def _on_scope_change(self, sel: str):
        self.scope_mode.set("general" if sel=="General" else "year" if sel=="Año" else "month")
        self._toggle_scope_widgets()

    def _toggle_scope_widgets(self):
        mode = self.scope_mode.get()
        self.year_sp.configure(state="normal" if mode in ("year","month") else "disabled")
        self.month_sp.configure(state="normal" if mode == "month" else "disabled")
        self.prepare_db()
        self.refresh_all()

    # --- Import ---
    def on_import(self):
        conn = connect(self.db_path)
        wiz = ImportWizard(self, conn, default_account="General")
        self.wait_window(wiz)
        try:
            conn.close()
        except Exception:
            pass
        self.refresh_all()

    # --- Body ---
    def _build_body(self):
        body = ttk.Frame(self, padding=(10,0,10,10)); body.pack(fill=tk.BOTH, expand=True)

        left_wrap, left_body = build_section(body, "Saldos por cuenta")
        left_wrap.pack(side=tk.LEFT, fill=tk.Y)
        ttk.Button(left_body, text="Cuentas…", bootstyle=SECONDARY, command=self.open_accounts_manager).pack(anchor="w", pady=(0,6))

        left_canvas = tk.Canvas(left_body, borderwidth=0, highlightthickness=0)
        vsb = ttk.Scrollbar(left_body, orient="vertical", command=left_canvas.yview)
        left_canvas.configure(yscrollcommand=vsb.set)
        vsb.pack(side=tk.RIGHT, fill=tk.Y); left_canvas.pack(side=tk.LEFT, fill=tk.Y)
        self.left_container = ttk.Frame(left_canvas)
        self.left_container.bind("<Configure>", lambda e: left_canvas.configure(scrollregion=left_canvas.bbox("all")))
        left_canvas.create_window((0,0), window=self.left_container, anchor="nw")

        center_wrap, center_body = build_section(body, "Tu última actividad")
        center_wrap.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(10,0))

        columns = ("fecha","desc","tipo","monto","cuenta")
        self.tv = ttk.Treeview(center_body, columns=columns, show="headings", height=18)
        for key, title in zip(columns, ["Fecha","Descripción","Tipo","Monto","Cuenta"]):
            self.tv.heading(key, text=title)
        self.tv.column("fecha",  width=110, anchor=tk.W)
        self.tv.column("desc",   width=380, anchor=tk.W)
        self.tv.column("tipo",   width=90,  anchor=tk.CENTER)
        self.tv.column("monto",  width=140, anchor=tk.E)
        self.tv.column("cuenta", width=180, anchor=tk.W)
        self.tv.pack(fill=tk.BOTH, expand=True)
        self.tv.tag_configure("ingreso", foreground="#31c48d")
        self.tv.tag_configure("egreso",  foreground="#e02424")
        self.tv.tag_configure("neutro",  foreground="#cbd5e1")
        tv_scroll = ttk.Scrollbar(center_body, orient="vertical", command=self.tv.yview)
        self.tv.configure(yscrollcommand=tv_scroll.set)
        tv_scroll.place(relx=1.0, rely=0, relheight=1.0, anchor="ne")

        self._tv_menu = tk.Menu(self.tv, tearoff=0)
        self._tv_menu.add_command(label="Eliminar movimiento", command=self.delete_selected_tx)
        self.tv.bind("<Button-3>", self._popup_tv)

    def _popup_tv(self, event):
        try:
            row_id = self.tv.identify_row(event.y)
            if row_id:
                self.tv.selection_set(row_id)
                self._tv_menu.tk_popup(event.x_root, event.y_root)
        finally:
            self._tv_menu.grab_release()

    # --- Carga de datos ---
    def get_accounts(self) -> list[dict]:
        with connect(self.db_path) as con:
            rows = con.execute("SELECT id, name, currency FROM account ORDER BY name").fetchall()
        return [{"id": r[0], "name": r[1], "currency": r[2]} for r in rows]

    def load_balances(self):
    """Rellena el panel izquierdo con tarjetas de saldo por cuenta y calcula total."""
    for w in self.left_container.winfo_children():
        w.destroy()

    rows = listar_saldos_por_cuenta(self.db_path)

    grp = ttk.Frame(self.left_container)
    grp.pack(anchor="w")

    for _acc_id, acc_name, curr, bal, _meta in rows:
        card = ttk.Frame(grp, padding=6, bootstyle=SECONDARY)
        card.pack(fill=tk.X, pady=4)
        ttk.Label(card, text=acc_name, font=("Helvetica", 10, "bold"),
                  bootstyle="inverse-secondary", anchor="w", padding=(4, 1)).pack(fill="x")
        ttk.Label(card, text=curr, bootstyle="inverse-secondary",
                  anchor="w", padding=(4, 1)).pack(fill="x")
        ttk.Label(card, text=money(bal, curr), font=("Helvetica", 12, "bold"),
                  bootstyle="inverse-secondary", anchor="w", padding=(4, 1)).pack(fill="x")


    def load_activity(self):
    """Carga últimos movimientos al Treeview central (máximo 500)."""
    # limpiar
    for i in self.tv.get_children():
        self.tv.delete(i)

    # usar servicio
    rows = listar_transacciones(self.db_path)
    for tx_id, posted_at, desc, amount, acc_name in rows:
        tag = "ingreso" if amount > 0 else "egreso" if amount < 0 else "neutro"
        tipo = "Ingreso" if amount > 0 else "Egreso" if amount < 0 else "—"
        self.tv.insert("", "end", iid=str(tx_id),
                       values=(posted_at, desc or "", tipo, money(amount), acc_name),
                       tags=(tag,))


    def refresh_all(self):
        self.prepare_db()
        # total disponible
        try:
            self.total_var.set(money(total_saldo(self.db_path)))
        except Exception:
            self.total_var.set(money(0))

        self.load_balances()
        self.load_activity()

    # --- Gestor de cuentas (solo stub para evitar errores si aún no lo usás) ---
    def open_accounts_manager(self):
        win = tb.Toplevel(self); win.title("Cuentas"); win.transient(self); win.grab_set()
        ttk.Label(win, text="(Gestor de cuentas en construcción)").pack(padx=12, pady=12)
        ttk.Button(win, text="Cerrar", command=win.destroy).pack(pady=8)

    # --- CRUD (añadir y borrar movimientos) ---
    def open_add_modal(self):
        win = tb.Toplevel(self); win.title("Añadir movimiento"); win.transient(self); win.grab_set(); win.resizable(False, False)
        frm = ttk.Frame(win, padding=12); frm.pack(fill=tk.BOTH, expand=True)

        accounts = self.get_accounts()
        if not accounts:
            ttk.Label(frm, text="No hay cuentas.\nCambiá a 'General' o creá en base general.", foreground="#ff8080").grid(row=0, column=0, columnspan=2, sticky="w")
            ttk.Button(frm, text="Cerrar", command=win.destroy).grid(row=1, column=1, sticky="e", padx=6, pady=8)
            return

        acc_labels = [f"{a['name']} ({a['currency']})" for a in accounts]
        acc_var = tk.StringVar(value=acc_labels[0]); date_var = tk.StringVar(value=date.today().isoformat())
        desc_var = tk.StringVar(value=""); monto_var = tk.StringVar(value=""); tipo_var = tk.IntVar(value=1)

        ttk.Label(frm, text="Cuenta").grid(row=0, column=0, sticky="w")
        ttk.Combobox(frm, values=acc_labels, state="readonly", width=40, textvariable=acc_var).grid(row=0, column=1, sticky="ew", padx=6, pady=4)
        ttk.Label(frm, text="Fecha (YYYY-MM-DD)").grid(row=1, column=0, sticky="w")
        ttk.Entry(frm, width=16, textvariable=date_var).grid(row=1, column=1, sticky="w", padx=6, pady=4)
        ttk.Label(frm, text="Descripción").grid(row=2, column=0, sticky="w")
        ttk.Entry(frm, width=42, textvariable=desc_var).grid(row=2, column=1, sticky="ew", padx=6, pady=4)

        ttk.Label(frm, text="Tipo").grid(row=3, column=0, sticky="w")
        box = ttk.Frame(frm); box.grid(row=3, column=1, sticky="w", padx=6, pady=4)
        ttk.Radiobutton(box, text="Ingreso (+)", variable=tipo_var, value=1).pack(side=tk.LEFT, padx=(0,10))
        ttk.Radiobutton(box, text="Egreso (–)",  variable=tipo_var, value=-1).pack(side=tk.LEFT)

        ttk.Label(frm, text="Monto (solo número)").grid(row=4, column=0, sticky="w")
        ent_monto = ttk.Entry(frm, width=20, textvariable=monto_var); ent_monto.grid(row=4, column=1, sticky="w", padx=6, pady=4)

        bar = ttk.Frame(frm); bar.grid(row=5, column=0, columnspan=2, sticky="e", pady=(10,0))
        ttk.Button(bar, text="Cancelar", bootstyle=SECONDARY, command=win.destroy).pack(side=tk.RIGHT, padx=6)

        def _validar_fecha(s: str) -> str:
            s = (s or "").strip()
            try:
                return datetime.strptime(s, "%Y-%m-%d").date().isoformat()
            except Exception:
                raise ValueError("La fecha debe ser YYYY-MM-DD (ej: 2025-10-12).")

        def guardar():
            try:
                idx = acc_labels.index(acc_var.get()) if acc_var.get() in acc_labels else 0
                acc_id = accounts[idx]["id"]
                posted = _validar_fecha(date_var.get())
                desc = (desc_var.get() or "").strip()
                amt_raw = parse_amount(monto_var.get())
                amt = abs(amt_raw) * (1 if tipo_var.get() >= 0 else -1)
                with connect(self.db_path) as con:
                    row = con.execute("SELECT currency FROM account WHERE id=?", (acc_id,)).fetchone()
                    if not row:
                        raise RuntimeError("Cuenta no encontrada.")
                    con.execute(
                        "INSERT INTO transactions(account_id, posted_at, description, amount, currency) VALUES (?,?,?,?,?)",
                        (acc_id, posted, desc, amt, row[0]),
                    )
                win.destroy(); self.refresh_all()
            except ValueError as e:
                messagebox.showerror("Datos inválidos", f"{e}\n\nEjemplos válidos: 5000 | 5.000,00 | -1.200,50 | $ 1.234,56", parent=win)
            except Exception as e:
                messagebox.showerror("Error al guardar", str(e), parent=win)

        ttk.Button(bar, text="Guardar", bootstyle=SUCCESS, command=guardar).pack(side=tk.RIGHT)
        frm.columnconfigure(1, weight=1)
        win.bind("<Escape>", lambda e: win.destroy())
        ent_monto.bind("<Return>", lambda e: guardar())

    def delete_selected_tx(self):
        sel = self.tv.selection()
        if not sel:
            return
        tx_id = int(sel[0])
        if not messagebox.askyesno("Confirmar", "¿Eliminar el movimiento seleccionado?"):
            return
        with connect(self.db_path) as con:
            con.execute("DELETE FROM transactions WHERE id=?", (tx_id,))
        self.refresh_all()

    # --- Exportar a Excel (CORRECTO) ---
    def export_to_excel(self):
        """Exporta cuentas y transacciones a un .xlsx."""
        try:
            import pandas as pd
        except Exception:
            messagebox.showerror("Exportar", "Necesitás instalar pandas y openpyxl para exportar a Excel.")
            return

        save_path = filedialog.asksaveasfilename(
            title="Guardar como",
            defaultextension=".xlsx",
            filetypes=[("Excel", "*.xlsx"), ("Todos", "*.*")],
        )
        if not save_path:
            return

        try:
            with connect(self.db_path) as con:
                acc = con.execute("SELECT id, name, currency FROM account ORDER BY name").fetchall()
                tx  = con.execute(
                    "SELECT t.id, t.posted_at, t.description, t.amount, t.currency, a.name AS account_name "
                    "FROM transactions t JOIN account a ON a.id=t.account_id "
                    "ORDER BY t.posted_at, t.id"
                ).fetchall()

            import pandas as pd
            df_acc = pd.DataFrame(acc, columns=["id","name","currency"])
            df_tx  = pd.DataFrame(tx,  columns=["id","posted_at","description","amount","currency","account_name"])

            with pd.ExcelWriter(save_path, engine="openpyxl") as xw:
                df_acc.to_excel(xw, index=False, sheet_name="accounts")
                df_tx.to_excel(xw,  index=False, sheet_name="transactions")

            messagebox.showinfo("Exportar", f"Archivo guardado en:\n{save_path}")
        except Exception as e:
            messagebox.showerror("Exportar", f"Error exportando: {e}")

# -------------------------------------------------------------------
# 5) main
# -------------------------------------------------------------------
if __name__ == "__main__":
    app = MPApp()
    app.mainloop()
